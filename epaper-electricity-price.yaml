esphome:
  name: electricity-price-display
  friendly_name: "Electricity price display"

  includes:
    - "ticks.h"

esp8266:
  board: nodemcuv2

# Enable logging
logger:

ota:
  - platform: esphome
    password: !secret ota_password
safe_mode:

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Display Fallback Hotspot"
    password: !secret fallback_hotspot_password

captive_portal:


external_components:
  # As of esphome version 2024.6.2, support for WeAct 2.9" RBW epaper
  # is in an unmerged pull request
  - source: "github://pr#6226"
    components: [waveshare_epaper]

network:
  enable_ipv6: true


globals:
  - id: hourly_prices
    type: "std::array<float, 48>"
    # TODO: maybe use fixed point instead; no native float in ESP8266
  - id: prices_start_date
    type: "ESPTime"
    # # initialize to a time whose is_valid() == false
    # initial_value: "ESPTime::from_epoch_utc(0)"
  - id: update_on_time_sync
    type: "bool"
    initial_value: "false"

# Home Assistant API
api:
  services:
    - service: set_prices
      variables:
        prices: float[]  # prices in cents
      then:
        - lambda: |-
            ESP_LOGI(
              "electricity_price_display", "new prices received: %s",
              [&]() {
                std::string str;
                for (float price : prices) {
                  str += ", ";
                  str += std::to_string(price);
                }
                return str;
              }().c_str() + 2);

            auto& dest = id(hourly_prices);

            auto len = prices.size();
            if (len < dest.size())
              ESP_LOGW(
              "electricity_price_display", "Fewer than %d items",
              dest.size());
            else if (len > dest.size())
              ESP_LOGW(
                "electricity_price_display",
                "More than %d items. Ignoring rest.", dest.size());

            auto dest_it = dest.begin();
            auto end = dest.end();
            for (float price : prices) {
              *dest_it = price;
              if (++dest_it == end)
                break;
            }
            for (; dest_it != end; ++dest_it)
              *dest_it = NAN;

            auto now = id(homeassistant_time).now();
            if (now.is_valid()) {
              id(prices_start_date) = now;
              id(epaper).update();
            } else {
              id(update_on_time_sync) = true;
            }


color:
  - id: red
    hex: "FF0000"

font:
  - # note: Font rendering is terribly ugly for some fonts, such as
    # Roboto and Open Sans. Arial seems to work nicely.
    file: "arial.ttf"
    id: main_font
    size: 15
    glyphs: "0123456789,"


spi:
  clk_pin: D1
  mosi_pin: D2

display:
  - platform: waveshare_epaper
    id: epaper
    cs_pin: D4  # also LED pin; LED used as update indicator
    dc_pin: D5
    reset_pin: D6
    busy_pin: D7
    model: 2.90in3c
    rotation: 90
    update_interval: never
    lambda: |-
      auto& disp = *id(epaper);
      const auto& font = id(main_font);
      const Color& color_red = id(red);

      const int BAR_WIDTH = 5;
      const int GRAPH_MARGIN_TOP = 6;  // space for topmost axis label

      // This should be divisible by as many of 2, 3, 4, and 5 as
      // possible (and also 7 and 9 as a secondary objective)
      const int GRAPH_YGRID_HEIGHT = 100;

      const int GRAPH_WIDTH = 48*BAR_WIDTH;
      const int GRAPH_HEIGHT = GRAPH_YGRID_HEIGHT + GRAPH_MARGIN_TOP;
      static const int screen_width = disp.get_width();
      static const int graph_margin_left = (screen_width - GRAPH_WIDTH)/2;
      static const int screen_height = disp.get_height();
      static const int graph_margin_bottom = screen_height - GRAPH_HEIGHT;

      const auto& prices = id(hourly_prices);

      const float max_price =
        *std::max_element(prices.cbegin(), prices.cend());

      // TODO: use space above y-grid
      const auto yticks = pleasing_ticks(
        std::isfinite(max_price) ? std::ceil(max_price) : 0);
      const auto max_ygrid_val = yticks[0];

      auto prices_it = prices.cbegin();
      const auto prices_end = prices.cend();

      // prices comprises 2 days of data. If we're at 2nd day, skip 1st day.
      auto now = id(homeassistant_time).now();
      auto start_date = id(prices_start_date);
      if (now.year != start_date.year ||
          now.day_of_year != start_date.day_of_year)
        prices_it += 24;

      for (int hour=0, x = graph_margin_left;
           prices_it != prices_end;
           ++hour, ++prices_it, x += BAR_WIDTH)
      {
        // TODO: price < 0
        float height = std::round(
          GRAPH_YGRID_HEIGHT * *prices_it / max_ygrid_val);
        ESP_LOGD("electricity_price_display", "hour %02d: height = %f",
                 hour, height);
        if (std::isfinite(height))
          it.filled_rectangle(
            x + 1, GRAPH_HEIGHT - (int)height,
            BAR_WIDTH-1, (int)height,
            (hour == now.hour) ? color_red : display::COLOR_ON);
          if (hour == now.hour)
            for (int y=1; y < screen_height; y += 2)
              it.draw_pixel_at(x + (BAR_WIDTH+1)/2, y, color_red);
      }

      struct axis_label { int pos; const char* label; };

      // x-axis grid
      for (auto [hour, label] : (axis_label[]) {
        {0, "00"}, {6, "06"}, {12, "12"}, {18, "18"},
        {24, "00"}, {30, "06"}, {36, "12"}, {42, "18"},
        {48, "00"}
      }) {
        int x = graph_margin_left + hour*BAR_WIDTH;
        for (int y=0; y < GRAPH_HEIGHT; y += 3)
          it.draw_pixel_at(x, y);
        it.vertical_line(x, screen_height - graph_margin_bottom , 3);
        it.print(
          x, screen_height - graph_margin_bottom  + 4,
          font, TextAlign::TOP_CENTER,
          label);
      }

      // y-axis grid
      for (auto tick_val : yticks) {
        int y = GRAPH_HEIGHT -
          (GRAPH_YGRID_HEIGHT * tick_val) / max_ygrid_val;
        auto label_str = std::to_string(tick_val);
        const char* label = label_str.c_str();

        for (int x = graph_margin_left;
             x < GRAPH_WIDTH + graph_margin_left;
             x += 3)
          it.draw_pixel_at(x, y);
        it.horizontal_line(graph_margin_left - 4, y, 4);
        it.print(
          graph_margin_left - 4 - 1, y,
          font, TextAlign::CENTER_RIGHT,
          label);
        it.horizontal_line(graph_margin_left + GRAPH_WIDTH, y, 4);
        it.print(
          graph_margin_left + GRAPH_WIDTH + 4 + 1, y,
          font, TextAlign::CENTER_LEFT,
          label);
      }
      // gridline 0 without text or solid tick lines
      // (text would overlap with x-axis labels)
      for (int x = graph_margin_left - 4;
           x < GRAPH_WIDTH + graph_margin_left + 4;
           x += 3)
        it.draw_pixel_at(x, GRAPH_HEIGHT);


time:
  - platform: homeassistant
    id: homeassistant_time
    timezone: "Europe/Helsinki"
    on_time:
      seconds: 0
      minutes: 0
      then:
        - lambda: |-
            id(epaper).update();
    on_time_sync:
      then:
        - lambda: |-
            if (id(update_on_time_sync)) {
              id(update_on_time_sync) = false;
              id(prices_start_date) = id(homeassistant_time).now();
              id(epaper).update();
            }
