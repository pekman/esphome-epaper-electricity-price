esphome:
  name: electricity-price-display
  friendly_name: "Electricity price display"

  includes:
    - "ticks.h"

  on_boot:
    - priority: 10000  # as early as possible
      then:
        - lambda: |-
            // initialize hourly_prices with NaNs to indicate no data
            for (float& price : id(hourly_prices))
              price = NAN;

    - priority: -100  # when everything else should already be initialized
      then:
        - logger.log: "Setting up initial data update check"
        - delay: 5min
        - lambda: |-
            // if no data yet received, update display to show alert
            if (!id(prices_start_date).is_valid())
              id(epaper).update();

esp8266:
  board: nodemcuv2

# Enable logging
logger:

ota:
  - platform: esphome
    password: !secret ota_password
safe_mode:

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Display Fallback Hotspot"
    password: !secret fallback_hotspot_password

captive_portal:


external_components:
  # As of esphome version 2024.6.2, support for WeAct 2.9" RBW epaper
  # is in an unmerged pull request
  - source: "github://pr#6226"
    components: [waveshare_epaper]

network:
  enable_ipv6: true


globals:
  - id: hourly_prices
    type: "std::array<float, 48>"
    # initialized to NaN in on_boot
    # TODO: maybe use fixed point instead; no native float in ESP8266

  - id: prices_start_date
    type: "ESPTime"
    # Initialize to a time whose is_valid() == false.
    # Invalid time means that initial data has not yet been received.
    initial_value: "ESPTime::from_epoch_utc(0)"

  - id: update_on_time_sync
    type: "bool"
    initial_value: "false"

# Home Assistant API
api:
  services:
    - service: set_prices
      variables:
        prices: float[]  # prices in cents
      then:
        - lambda: |-
            ESP_LOGI(
              "electricity_price_display", "new prices received: %s",
              [&]() {
                std::string str;
                for (float price : prices) {
                  str += ", ";
                  str += std::to_string(price);
                }
                return str;
              }().c_str() + 2);

            auto& dest = id(hourly_prices);

            auto len = prices.size();
            if (len < dest.size())
              ESP_LOGW(
              "electricity_price_display", "Fewer than %d items",
              dest.size());
            else if (len > dest.size())
              ESP_LOGW(
                "electricity_price_display",
                "More than %d items. Ignoring rest.", dest.size());

            auto dest_it = dest.begin();
            auto end = dest.end();
            for (float price : prices) {
              *dest_it = price;
              if (++dest_it == end)
                break;
            }
            for (; dest_it != end; ++dest_it)
              *dest_it = NAN;

            auto now = id(homeassistant_time).now();
            if (now.is_valid()) {
              id(prices_start_date) = now;
              id(epaper).update();
            } else {
              id(update_on_time_sync) = true;
            }


color:
  - id: red
    hex: "FF0000"

font:
  - # note: Font rendering is terribly ugly for some fonts, such as
    # Roboto and Open Sans. Arial seems to work nicely.
    file: "arial.ttf"
    id: main_font
    size: 15
    glyphs: "0123456789,"

image:
  - file: "mdi:robot-dead-outline"
    id: no_data_icon
    resize: 128x128


spi:
  clk_pin: D1
  mosi_pin: D2

display:
  - platform: waveshare_epaper
    id: epaper
    cs_pin: D4  # also LED pin; LED used as update indicator
    dc_pin: D5
    reset_pin: D6
    busy_pin: D7
    model: 2.90in3c
    rotation: 90
    update_interval: never
    lambda: |-
      auto& disp = *id(epaper);
      const auto& font = id(main_font);
      const Color& color_red = id(red);

      const int BAR_WIDTH = 5;
      const int GRAPH_MARGIN_TOP = 6;  // space for topmost axis label

      // This should be divisible by as many of 2, 3, 4, and 5 as
      // possible (and also 7 and 9 as a secondary objective)
      const int GRAPH_YGRID_HEIGHT = 100;

      const int HOUR_INDICATOR_HEIGHT = 4;

      const int GRAPH_WIDTH = 48*BAR_WIDTH;
      const int GRAPH_HEIGHT = GRAPH_YGRID_HEIGHT + GRAPH_MARGIN_TOP;
      static const int screen_width = disp.get_width();
      static const int graph_margin_left = (screen_width - GRAPH_WIDTH)/2;
      static const int screen_height = disp.get_height();
      static const int graph_margin_bottom = screen_height - GRAPH_HEIGHT;

      const auto& prices = id(hourly_prices);

      float max_price = -INFINITY;
      // Calculate max value NaN-safely.
      // If all values are NaN, max_price = -INFINITY.
      for (float price : prices)
        if (price > max_price)
          max_price = price;

      // show alert icon if no actual values
      if (!std::isfinite(max_price)) {
        ESP_LOGW("electricity_price_display", "No data!");
        it.image(
          screen_width / 2, screen_height / 2,
          id(no_data_icon),
          ImageAlign::CENTER);
        return;
      }

      const auto yticks = pleasing_ticks(
        // Use space above top y-gridline.
        // Calculate tick placement using a scaled top value.
        std::ceil((max_price * GRAPH_YGRID_HEIGHT) / GRAPH_HEIGHT));
      const auto max_ygrid_val = yticks[0];

      auto prices_it = prices.cbegin();
      const auto prices_end = prices.cend();

      // prices comprises 2 days of data. If we're at 2nd day, skip 1st day.
      auto now = id(homeassistant_time).now();
      auto start_date = id(prices_start_date);
      if (now.year != start_date.year ||
          now.day_of_year != start_date.day_of_year)
        prices_it += 24;

      // draw bars
      for (int hour=0, left_x = graph_margin_left;
           prices_it != prices_end;
           ++hour, ++prices_it, left_x += BAR_WIDTH)
      {
        float height_f = std::round(
          GRAPH_YGRID_HEIGHT * *prices_it / max_ygrid_val);
        ESP_LOGD("electricity_price_display", "hour %02d: height = %f",
                 hour, height_f);
        int height = std::isfinite(height_f) ? height_f : 0;

        // draw bar
        if (height != 0) {
          int x0 = left_x + 1;
          int w = BAR_WIDTH - 1;

          int y0, h;
          if (height > 0) {
            y0 = GRAPH_HEIGHT - height;
            h = height;
          } else {  // height < 0
            y0 = GRAPH_HEIGHT,
            h = std::min(-height, graph_margin_bottom);
          }

          if (hour >= now.hour)
            it.filled_rectangle(
              x0, y0, w, h,
              hour == now.hour ? color_red : display::COLOR_ON);
          else
            // draw dithered gray rectangle
            for (int y = y0; y < y0+h; ++y)
              for (int x = x0; x < x0+w; ++x)
                if ((x & 1) ^ (y & 1))  // every 2nd pixel
                  it.draw_pixel_at(x, y, display::COLOR_ON);
        }

        // draw current hour indicator
        if (hour == now.hour) {
          int center_x = left_x + BAR_WIDTH/2;
          for (int y=1; y < screen_height; y += 2)
            it.draw_pixel_at(center_x, y, color_red);

          // draw triangle at bottom and also at top if it doesn't
          // overlap with price bar
          for (int y = screen_height - HOUR_INDICATOR_HEIGHT,
                   x = center_x, w = 1;
               y < screen_height;
               ++y, --x, w += 2)
            it.horizontal_line(x, y, w, color_red);
          if (GRAPH_HEIGHT - height > HOUR_INDICATOR_HEIGHT)
            for (int y = HOUR_INDICATOR_HEIGHT - 1, x = center_x, w = 1;
                 y >= 0;
                 --y, --x, w += 2)
              it.horizontal_line(x, y, w, color_red);
        }
      }

      struct axis_label { int pos; const char* label; };

      // x-axis grid
      for (auto [hour, label] : (axis_label[]) {
        {0, "00"}, {6, "06"}, {12, "12"}, {18, "18"},
        {24, "00"}, {30, "06"}, {36, "12"}, {42, "18"},
        {48, "00"}
      }) {
        int x = graph_margin_left + hour*BAR_WIDTH;
        for (int y=0; y < GRAPH_HEIGHT; y += 3)
          it.draw_pixel_at(x, y);
        it.vertical_line(x, screen_height - graph_margin_bottom , 3);
        it.print(
          x, screen_height - graph_margin_bottom  + 4,
          font, TextAlign::TOP_CENTER,
          label);
      }

      // y-axis grid
      for (auto tick_val : yticks) {
        int y = GRAPH_HEIGHT -
          (GRAPH_YGRID_HEIGHT * tick_val) / max_ygrid_val;
        auto label_str = std::to_string(tick_val);
        const char* label = label_str.c_str();

        for (int x = graph_margin_left;
             x < GRAPH_WIDTH + graph_margin_left;
             x += 3)
          it.draw_pixel_at(x, y);
        it.horizontal_line(graph_margin_left - 4, y, 4);
        it.print(
          graph_margin_left - 4 - 1, y,
          font, TextAlign::CENTER_RIGHT,
          label);
        it.horizontal_line(graph_margin_left + GRAPH_WIDTH, y, 4);
        it.print(
          graph_margin_left + GRAPH_WIDTH + 4 + 1, y,
          font, TextAlign::CENTER_LEFT,
          label);
      }
      // gridline 0 without text or solid tick lines
      // (text would overlap with x-axis labels)
      for (int x = graph_margin_left - 4;
           x < GRAPH_WIDTH + graph_margin_left + 4;
           x += 3)
        it.draw_pixel_at(x, GRAPH_HEIGHT);


time:
  - platform: homeassistant
    id: homeassistant_time
    timezone: "Europe/Helsinki"
    on_time:
      seconds: 0
      minutes: 0
      then:
        - lambda: |-
            // update display, unless we're still waiting for initial data
            if (id(prices_start_date).is_valid())
              id(epaper).update();
    on_time_sync:
      then:
        - lambda: |-
            if (id(update_on_time_sync)) {
              id(update_on_time_sync) = false;
              id(prices_start_date) = id(homeassistant_time).now();
              id(epaper).update();
            }
